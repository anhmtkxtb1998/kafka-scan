"""Kafka worker that performs nmap vulnerability scans.

The implementation mirrors the style of the other scanning services in the
repository (``scan_ip`` and ``scan_full_port``) but it focuses on running the
``vuln`` family of NSE scripts. Each Kafka message should at least contain an
``ip`` field. Optional fields allow the caller to customise the nmap arguments
and the target port list.
"""

from __future__ import annotations

import json
import os
import sys
from collections import OrderedDict
from datetime import datetime
from threading import Thread
from typing import Any, Dict, Iterable, List

import nmap
from dotenv import load_dotenv
from kafka import KafkaConsumer, KafkaProducer

load_dotenv()

try:
    from scan_vulnerability.config import (
        DEFAULT_VULN_ARGS,
        KAFKA_BOOTSTRAP_SERVERS,
        MAX_WORKERS,
        TOPIC_VULN_RESULTS,
        TOPIC_VULN_TASKS,
    )
except Exception:  # pragma: no cover - fallback when executed from this folder directly
    DEFAULT_VULN_ARGS = os.getenv(
        "DEFAULT_VULN_ARGS", "--script vuln -sV -T4 --min-rate 500 --max-retries 1"
    )
    KAFKA_BOOTSTRAP_SERVERS = os.getenv("KAFKA_BOOTSTRAP_SERVERS", "192.168.89.138:9092")
    TOPIC_VULN_TASKS = os.getenv("TOPIC_VULN_TASKS", "scan-vuln-topic")
    TOPIC_VULN_RESULTS = os.getenv("TOPIC_VULN_RESULTS", "scan-vuln-results")
    MAX_WORKERS = int(os.getenv("VULN_MAX_WORKERS", "2"))


def create_consumer(index: int) -> KafkaConsumer:
    """Return a Kafka consumer for vulnerability scanning tasks."""

    return KafkaConsumer(
        TOPIC_VULN_TASKS,
        bootstrap_servers=KAFKA_BOOTSTRAP_SERVERS,
        group_id="scan_vuln_consumer",
        client_id=f"scan_vuln_worker_{index}",
        value_deserializer=lambda m: json.loads(m.decode("utf-8")),
        auto_offset_reset="earliest",
        enable_auto_commit=True,
    )


def create_producer() -> KafkaProducer:
    """Return a Kafka producer used to publish vulnerability scan results."""

    return KafkaProducer(
        bootstrap_servers=KAFKA_BOOTSTRAP_SERVERS,
        value_serializer=lambda v: json.dumps(v, ensure_ascii=False).encode("utf-8"),
    )


def _flatten_ports(raw_ports: Any) -> List[str]:
    """Normalise the ``ports`` specification supplied by a task.

    The helper accepts a variety of input formats (string, number, iterable)
    and converts them into a de-duplicated list of strings that is suitable for
    the ``-p`` argument of nmap.
    """

    values: List[str] = []

    def _append(value: Any) -> None:
        if value is None:
            return
        if isinstance(value, str):
            parts = [part.strip() for part in value.split(",") if part.strip()]
            values.extend(parts)
        elif isinstance(value, Iterable) and not isinstance(
            value, (bytes, bytearray, dict)
        ):
            for item in value:
                _append(item)
        else:
            try:
                number = int(value)
            except (TypeError, ValueError):
                return
            values.append(str(number))

    _append(raw_ports)
    ordered_unique = OrderedDict((val, None) for val in values)
    return list(ordered_unique.keys())


def build_scan_arguments(task: Dict[str, Any]) -> str:
    """Compose the final nmap arguments for a task.

    ``scan_args`` within the task overrides the default arguments.  When the
    task specifies a list of ports and the arguments do not already contain a
    ``-p`` flag, the ports are appended automatically.
    """

    base_args = str(task.get("scan_args") or DEFAULT_VULN_ARGS).strip()
    ports = _flatten_ports(task.get("ports"))
    if ports and "-p" not in base_args:
        base_args = f"{base_args} -p {','.join(ports)}"

    script_args = task.get("script_args")
    if script_args and "--script-args" not in base_args:
        base_args = f"{base_args} --script-args {script_args}"

    return " ".join(base_args.split())


def _extract_os_info(host_data: nmap.PortScannerHostDict) -> Dict[str, Any]:
    os_matches = host_data.get("osmatch") or []
    if not os_matches:
        return {}
    best = os_matches[0]
    os_info: Dict[str, Any] = {
        "name": best.get("name"),
        "accuracy": best.get("accuracy"),
    }
    os_classes = best.get("osclass")
    if isinstance(os_classes, list) and os_classes:
        os_info["osclass"] = os_classes[0]
    return os_info


def _build_vulnerability_details(
    port_data: Dict[str, Any],
    protocol: str,
    scan_args: str,
) -> Dict[str, Any]:
    scripts = []
    for script_id, output in (port_data.get("script") or {}).items():
        scripts.append({"id": script_id, "output": output})

    detail = {
        "protocol": protocol,
        "service": {
            "name": port_data.get("name"),
            "product": port_data.get("product"),
            "version": port_data.get("version"),
            "extrainfo": port_data.get("extrainfo"),
        },
        "cpe": port_data.get("cpe"),
        "reason": port_data.get("reason"),
        "scripts": scripts,
        "scan_args": scan_args,
    }
    return detail


def scan_vulnerabilities(task: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Execute a vulnerability scan for the supplied task."""

    ip = task.get("ip")
    if not ip:
        print("âš ï¸  Task thiáº¿u trÆ°á»ng 'ip'. Bá» qua.")
        return []

    ip_range_id = task.get("ip_range_id")
    scan_args = build_scan_arguments(task)
    timestamp = datetime.utcnow().isoformat()

    scanner = nmap.PortScanner()
    print(f"ðŸ›¡ï¸  QuÃ©t lá»— há»•ng cho {ip} vá»›i args: {scan_args}")

    try:
        scanner.scan(hosts=ip, arguments=scan_args)
    except nmap.PortScannerError as exc:
        print(f"âŒ Lá»—i nmap khi quÃ©t {ip}: {exc}")
        return [
            {
                "task_id": task.get("task_id"),
                "ip_range_id": ip_range_id,
                "ip": ip,
                "port": None,
                "status_port": "scan-error",
                "first_detect": timestamp,
                "last_scan": timestamp,
                "os": {},
                "vuln": {
                    "scan_args": scan_args,
                    "error": str(exc),
                },
            }
        ]
    except Exception as exc:  # pragma: no cover - defensive guard
        print(f"âŒ Lá»—i khÃ´ng mong muá»‘n khi quÃ©t {ip}: {exc}")
        return [
            {
                "task_id": task.get("task_id"),
                "ip_range_id": ip_range_id,
                "ip": ip,
                "port": None,
                "status_port": "scan-error",
                "first_detect": timestamp,
                "last_scan": timestamp,
                "os": {},
                "vuln": {
                    "scan_args": scan_args,
                    "error": str(exc),
                },
            }
        ]

    results: List[Dict[str, Any]] = []
    hosts = scanner.all_hosts()
    if not hosts:
        print(f"â„¹ï¸  Nmap khÃ´ng tráº£ vá» host nÃ o cho {ip}.")
    else:
        for host in hosts:
            host_data = scanner[host]
            os_info = _extract_os_info(host_data)
            protocols = host_data.all_protocols()
            for proto in protocols:
                port_entries = host_data[proto]
                for port, port_data in port_entries.items():
                    state = port_data.get("state", "unknown")
                    detail = _build_vulnerability_details(port_data, proto, scan_args)
                    results.append(
                        {
                            "task_id": task.get("task_id"),
                            "ip_range_id": ip_range_id,
                            "ip": host,
                            "port": port,
                            "status_port": state,
                            "first_detect": timestamp,
                            "last_scan": timestamp,
                            "os": os_info,
                            "vuln": detail,
                        }
                    )

    if not results:
        # Always emit at least one record so downstream services know the scan ran.
        results.append(
            {
                "task_id": task.get("task_id"),
                "ip_range_id": ip_range_id,
                "ip": ip,
                "port": None,
                "status_port": "no-findings",
                "first_detect": timestamp,
                "last_scan": timestamp,
                "os": {},
                "vuln": {
                    "scan_args": scan_args,
                    "message": "KhÃ´ng tÃ¬m tháº¥y dá»‹ch vá»¥ má»Ÿ hoáº·c script khÃ´ng tráº£ káº¿t quáº£.",
                },
            }
        )

    return results


def publish_results(producer: KafkaProducer, results: List[Dict[str, Any]]) -> None:
    for entry in results:
        producer.send(TOPIC_VULN_RESULTS, entry)
    producer.flush()


def consumer_worker(index: int) -> None:
    consumer = create_consumer(index)
    producer = create_producer()
    print(f"ðŸ“¡ Worker quÃ©t lá»— há»•ng #{index} khá»Ÿi Ä‘á»™ng...")

    try:
        for message in consumer:
            task = message.value
            try:
                results = scan_vulnerabilities(task)
                if results:
                    publish_results(producer, results)
                    print(
                        f"âœ… Worker #{index} Ä‘Ã£ gá»­i {len(results)} káº¿t quáº£ cho {task.get('ip')}"
                    )
                else:
                    print(f"âš ï¸ Worker #{index} khÃ´ng cÃ³ káº¿t quáº£ cho {task.get('ip')}")
            except Exception as exc:  # pragma: no cover - guard unexpected errors
                print(f"âŒ Worker #{index} lá»—i xá»­ lÃ½ task: {exc}")
    except KeyboardInterrupt:
        print(f"ðŸ›‘ Worker #{index} dá»«ng bá»Ÿi ngÆ°á»i dÃ¹ng.")
    finally:
        consumer.close()


if __name__ == "__main__":
    worker_total = MAX_WORKERS if MAX_WORKERS > 0 else 1
    threads: List[Thread] = []
    print(f"ðŸš€ Khá»Ÿi Ä‘á»™ng {worker_total} worker quÃ©t lá»— há»•ng...")
    for i in range(worker_total):
        thread = Thread(target=consumer_worker, args=(i + 1,), daemon=True)
        thread.start()
        threads.append(thread)

    try:
        for thread in threads:
            thread.join()
    except KeyboardInterrupt:
        print("ðŸ›‘ Dá»«ng toÃ n bá»™ worker.")
        sys.exit(0)
