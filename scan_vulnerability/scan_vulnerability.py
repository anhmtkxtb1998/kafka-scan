"""Kafka worker that performs nmap vulnerability scans.

The implementation mirrors the style of the other scanning services in the
repository (``scan_ip`` and ``scan_full_port``) but it focuses on running the
``vuln`` family of NSE scripts. Each Kafka message should at least contain an
``ip`` field. Optional fields allow the caller to customise the nmap arguments
and the target port list.
"""

from __future__ import annotations

import json
import os
import sys
from collections import OrderedDict
from datetime import datetime
from threading import Thread
from typing import Any, Dict, Iterable, List

import nmap
from dotenv import load_dotenv
from kafka import KafkaConsumer, KafkaProducer

load_dotenv()

try:
    from scan_vulnerability.config import (
        DEFAULT_VULN_ARGS,
        KAFKA_BOOTSTRAP_SERVERS,
        MAX_WORKERS,
        TOPIC_VULN_RESULTS,
        TOPIC_VULN_TASKS,
    )
except Exception:  # pragma: no cover - fallback when executed from this folder directly
    DEFAULT_VULN_ARGS = os.getenv(
        "DEFAULT_VULN_ARGS", "--script vuln -sV -T4 --min-rate 500 --max-retries 1"
    )
    KAFKA_BOOTSTRAP_SERVERS = os.getenv("KAFKA_BOOTSTRAP_SERVERS", "192.168.89.138:9092")
    TOPIC_VULN_TASKS = os.getenv("TOPIC_VULN_TASKS", "scan-vuln-topic")
    TOPIC_VULN_RESULTS = os.getenv("TOPIC_VULN_RESULTS", "scan-vuln-results")
    MAX_WORKERS = int(os.getenv("VULN_MAX_WORKERS", "2"))


def create_consumer(index: int) -> KafkaConsumer:
    """Return a Kafka consumer for vulnerability scanning tasks."""

    return KafkaConsumer(
        TOPIC_VULN_TASKS,
        bootstrap_servers=KAFKA_BOOTSTRAP_SERVERS,
        group_id="scan_vuln_consumer",
        client_id=f"scan_vuln_worker_{index}",
        value_deserializer=lambda m: json.loads(m.decode("utf-8")),
        auto_offset_reset="earliest",
        enable_auto_commit=True,
    )


def create_producer() -> KafkaProducer:
    """Return a Kafka producer used to publish vulnerability scan results."""

    return KafkaProducer(
        bootstrap_servers=KAFKA_BOOTSTRAP_SERVERS,
        value_serializer=lambda v: json.dumps(v, ensure_ascii=False).encode("utf-8"),
    )


def _flatten_ports(raw_ports: Any) -> List[str]:
    """Normalise the ``ports`` specification supplied by a task.

    The helper accepts a variety of input formats (string, number, iterable)
    and converts them into a de-duplicated list of strings that is suitable for
    the ``-p`` argument of nmap.
    """

    values: List[str] = []

    def _append(value: Any) -> None:
        if value is None:
            return
        if isinstance(value, str):
            parts = [part.strip() for part in value.split(",") if part.strip()]
            values.extend(parts)
        elif isinstance(value, Iterable) and not isinstance(
            value, (bytes, bytearray, dict)
        ):
            for item in value:
                _append(item)
        else:
            try:
                number = int(value)
            except (TypeError, ValueError):
                return
            values.append(str(number))

    _append(raw_ports)
    ordered_unique = OrderedDict((val, None) for val in values)
    return list(ordered_unique.keys())


def build_scan_arguments(task: Dict[str, Any]) -> str:
    """Compose the final nmap arguments for a task.

    ``scan_args`` within the task overrides the default arguments.  When the
    task specifies a list of ports and the arguments do not already contain a
    ``-p`` flag, the ports are appended automatically.
    """

    base_args = str(task.get("scan_args") or DEFAULT_VULN_ARGS).strip()
    ports = _flatten_ports(task.get("ports"))
    if ports and "-p" not in base_args:
        base_args = f"{base_args} -p {','.join(ports)}"

    script_args = task.get("script_args")
    if script_args and "--script-args" not in base_args:
        base_args = f"{base_args} --script-args {script_args}"

    return " ".join(base_args.split())


def _extract_os_info(host_data: nmap.PortScannerHostDict) -> Dict[str, Any]:
    os_matches = host_data.get("osmatch") or []
    if not os_matches:
        return {}
    best = os_matches[0]
    os_info: Dict[str, Any] = {
        "name": best.get("name"),
        "accuracy": best.get("accuracy"),
    }
    os_classes = best.get("osclass")
    if isinstance(os_classes, list) and os_classes:
        os_info["osclass"] = os_classes[0]
    return os_info


def _build_vulnerability_details(
    port_data: Dict[str, Any],
    protocol: str,
    scan_args: str,
) -> Dict[str, Any]:
    scripts = []
    for script_id, output in (port_data.get("script") or {}).items():
        scripts.append({"id": script_id, "output": output})

    detail = {
        "protocol": protocol,
        "service": {
            "name": port_data.get("name"),
            "product": port_data.get("product"),
            "version": port_data.get("version"),
            "extrainfo": port_data.get("extrainfo"),
        },
        "cpe": port_data.get("cpe"),
        "reason": port_data.get("reason"),
        "scripts": scripts,
        "scan_args": scan_args,
    }
    return detail


def scan_vulnerabilities(task: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Execute a vulnerability scan for the supplied task."""

    ip = task.get("ip")
    if not ip:
        print("⚠️  Task thiếu trường 'ip'. Bỏ qua.")
        return []

    ip_range_id = task.get("ip_range_id")
    scan_args = build_scan_arguments(task)
    timestamp = datetime.utcnow().isoformat()

    scanner = nmap.PortScanner()
    print(f"🛡️  Quét lỗ hổng cho {ip} với args: {scan_args}")

    try:
        scanner.scan(hosts=ip, arguments=scan_args)
    except nmap.PortScannerError as exc:
        print(f"❌ Lỗi nmap khi quét {ip}: {exc}")
        return [
            {
                "task_id": task.get("task_id"),
                "ip_range_id": ip_range_id,
                "ip": ip,
                "port": None,
                "status_port": "scan-error",
                "first_detect": timestamp,
                "last_scan": timestamp,
                "os": {},
                "vuln": {
                    "scan_args": scan_args,
                    "error": str(exc),
                },
            }
        ]
    except Exception as exc:  # pragma: no cover - defensive guard
        print(f"❌ Lỗi không mong muốn khi quét {ip}: {exc}")
        return [
            {
                "task_id": task.get("task_id"),
                "ip_range_id": ip_range_id,
                "ip": ip,
                "port": None,
                "status_port": "scan-error",
                "first_detect": timestamp,
                "last_scan": timestamp,
                "os": {},
                "vuln": {
                    "scan_args": scan_args,
                    "error": str(exc),
                },
            }
        ]

    results: List[Dict[str, Any]] = []
    hosts = scanner.all_hosts()
    if not hosts:
        print(f"ℹ️  Nmap không trả về host nào cho {ip}.")
    else:
        for host in hosts:
            host_data = scanner[host]
            os_info = _extract_os_info(host_data)
            protocols = host_data.all_protocols()
            for proto in protocols:
                port_entries = host_data[proto]
                for port, port_data in port_entries.items():
                    state = port_data.get("state", "unknown")
                    detail = _build_vulnerability_details(port_data, proto, scan_args)
                    results.append(
                        {
                            "task_id": task.get("task_id"),
                            "ip_range_id": ip_range_id,
                            "ip": host,
                            "port": port,
                            "status_port": state,
                            "first_detect": timestamp,
                            "last_scan": timestamp,
                            "os": os_info,
                            "vuln": detail,
                        }
                    )

    if not results:
        # Always emit at least one record so downstream services know the scan ran.
        results.append(
            {
                "task_id": task.get("task_id"),
                "ip_range_id": ip_range_id,
                "ip": ip,
                "port": None,
                "status_port": "no-findings",
                "first_detect": timestamp,
                "last_scan": timestamp,
                "os": {},
                "vuln": {
                    "scan_args": scan_args,
                    "message": "Không tìm thấy dịch vụ mở hoặc script không trả kết quả.",
                },
            }
        )

    return results


def publish_results(producer: KafkaProducer, results: List[Dict[str, Any]]) -> None:
    for entry in results:
        producer.send(TOPIC_VULN_RESULTS, entry)
    producer.flush()


def consumer_worker(index: int) -> None:
    consumer = create_consumer(index)
    producer = create_producer()
    print(f"📡 Worker quét lỗ hổng #{index} khởi động...")

    try:
        for message in consumer:
            task = message.value
            try:
                results = scan_vulnerabilities(task)
                if results:
                    publish_results(producer, results)
                    print(
                        f"✅ Worker #{index} đã gửi {len(results)} kết quả cho {task.get('ip')}"
                    )
                else:
                    print(f"⚠️ Worker #{index} không có kết quả cho {task.get('ip')}")
            except Exception as exc:  # pragma: no cover - guard unexpected errors
                print(f"❌ Worker #{index} lỗi xử lý task: {exc}")
    except KeyboardInterrupt:
        print(f"🛑 Worker #{index} dừng bởi người dùng.")
    finally:
        consumer.close()


if __name__ == "__main__":
    worker_total = MAX_WORKERS if MAX_WORKERS > 0 else 1
    threads: List[Thread] = []
    print(f"🚀 Khởi động {worker_total} worker quét lỗ hổng...")
    for i in range(worker_total):
        thread = Thread(target=consumer_worker, args=(i + 1,), daemon=True)
        thread.start()
        threads.append(thread)

    try:
        for thread in threads:
            thread.join()
    except KeyboardInterrupt:
        print("🛑 Dừng toàn bộ worker.")
        sys.exit(0)
